import type { Networkish } from "@ethersproject/providers";
import { Chains, ClientIdWithQuerierAndChainType } from "../../interfaces/EmbeddedWallets/EmbeddedWallets";
import { EmbeddedWalletIframeCommunicator } from "../../utils/iFrameCommunication/EmbeddedWalletIframeCommunicator";
import { LocalStorage } from "../../utils/Storage/LocalStorage";
import { GaslessTransactionMaker } from "./GaslessTransactionMaker";
import { EthersSigner } from "./Signer";
export declare type WalletManagementTypes = {
    createWallet: void;
    setUpNewDevice: void;
    getUserStatus: void;
    saveDeviceShare: {
        deviceShareStored: string;
    };
};
export declare type WalletManagementUiTypes = {
    createWalletUi: void;
    setUpNewDeviceUi: void;
};
export declare type EmbeddedWalletInternalHelperType = {
    showUi: boolean;
};
export declare class EmbeddedWallet {
    protected clientId: string;
    protected chain: Chains;
    protected walletManagerQuerier: EmbeddedWalletIframeCommunicator<WalletManagementTypes & WalletManagementUiTypes>;
    protected localStorage: LocalStorage;
    gasless: GaslessTransactionMaker;
    /**
     * Not meant to be initialized directly. Call {@link .initializeUser} to get an instance
     * @param param0
     */
    constructor({ clientId, chain, querier }: ClientIdWithQuerierAndChainType);
    private postSetUpWallet;
    /**
     * @private
     * @returns {{walletAddress: string, initialUserStatus: UserWalletStatus}} an object containing the user's wallet address
     */
    private createWallet;
    /**
     * @private
     * @param {Object} props options to either show or not show UI.
     * @returns {{walletAddress: string, initialUserStatus: UserWalletStatus}} an object containing the user's wallet address
     */
    private setUpNewDevice;
    /**
     * @description
     * Switches the chain that the user wallet is currently on.
     * @example
     * // user wallet will be set to Polygon
     * const Paper = new PaperEmbeddedWalletSdk({clientId: "", chain: "Polygon"});
     * const user = await Paper.initializeUser();
     * // user wallet is not on Mumbai
     * await user.wallet.setChain({ chain: "Mumbai" });
     * @param {Chains} params.chain The chain that we are changing the user wallet too
     */
    setChain({ chain }: {
        chain: Chains;
    }): Promise<void>;
    /**
     * Returns an Ethers.Js compatible signer that you can use in conjunction with the rest of dApp
     * @example
     * const Paper = new PaperEmbeddedWalletSdk({clientId: "", chain: "Polygon"});
     * const user = await Paper.initializeUser();
     * // returns a signer on the Polygon mainnet
     * const signer = await user.getEthersJsSigner();
     * // returns a signer that is on the ethereum mainnet
     * const signer = await user.getEthersJsSigner({rpcEndpoint: "https://eth-rpc.gateway.pokt.network"});
     * @param {Networkish} network.rpcEndpoint the rpc url where calls will be routed through
     * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link PaperEmbeddedWalletSdk.initializeUser} before accessing this function
     * @returns A signer that is compatible with Ether.js. Defaults to the public rpc on the chain specified when initializing the {@link PaperEmbeddedWalletSdk} instance
     */
    getEthersJsSigner(network?: {
        rpcEndpoint: Networkish;
    }): Promise<EthersSigner>;
    /**
     * Convenience function to get the user's wallet address
     * @throws If attempting to call the function without the user wallet initialize on their current device. This should never happen if call {@link PaperEmbeddedWalletSdk.initializeUser} before accessing this function
     * @returns {string} the wallet address of the user
     */
    getAddress(): Promise<string>;
}
