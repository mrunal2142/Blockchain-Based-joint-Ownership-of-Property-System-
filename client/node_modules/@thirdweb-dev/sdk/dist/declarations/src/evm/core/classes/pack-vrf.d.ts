import { NetworkInput, TransactionResultWithId } from "..";
import { PackRewards, SDKOptions } from "../../schema";
import { Amount, CurrencyValue } from "../../types";
import { DetectableFeature } from "../interfaces/DetectableFeature";
import { UpdateableNetwork } from "../interfaces/contract";
import { ContractWrapper } from "./contract-wrapper";
import type { PackVRFDirect } from "@thirdweb-dev/contracts-js";
import { ThirdwebStorage } from "@thirdweb-dev/storage";
import { BigNumberish } from "ethers";
export declare class PackVRF implements UpdateableNetwork, DetectableFeature {
    featureName: "PackVRF";
    private contractWrapper;
    private storage;
    chainId: number;
    private events;
    constructor(network: NetworkInput, address: string, storage: ThirdwebStorage, options: SDKOptions, chainId: number, contractWrapper?: ContractWrapper<PackVRFDirect>);
    onNetworkUpdated(network: NetworkInput): void;
    getAddress(): string;
    /**
     * Open a pack using Chainlink VRFs random number generation
     * This will return a transaction result with the requestId of the open request, NOT the contents of the pack
     * To get the contents of the pack, you must call claimRewards once the VRF request has been fulfilled
     * You can use the canClaimRewards method to check if the VRF request has been fulfilled
     * @param tokenId
     * @param amount
     * @returns
     */
    open(tokenId: BigNumberish, amount?: BigNumberish): Promise<TransactionResultWithId>;
    /**
     * Claim the rewards from a pack that has been opened
     * This will return the contents of the pack
     * Make sure to check if the VRF request has been fulfilled using canClaimRewards() before calling this method
     * @returns the random rewards from opening a pack
     */
    claimRewards(): Promise<PackRewards>;
    private parseRewards;
    /**
     * Setup a listener that will be called everytime a pack is opened in this contract
     * @param callback the listener to call when a pack is opened
     * @returns a unsubscribe function to cleanup the listener
     */
    addPackOpenEventListener(callback: (packId: string, openerAddress: string, rewards: PackRewards) => void): Promise<() => void>;
    /**
     * Check if the connected address can claim rewards after opening a pack
     * @param claimerAddress Optional: the address to check if they can claim rewards, defaults to the connected address
     * @returns whether the connected address can claim rewards after opening a pack
     */
    canClaimRewards(claimerAddress?: string): Promise<boolean>;
    /**
     * Open a pack and claim the rewards in one transaction.
     * This function will only start the flow of opening a pack, the rewards will be granted automatically to the connected address after VRF request is fulfilled
     * @param packId The id of the pack to open
     * @param amount Optional: the amount of packs to open, defaults to 1
     * @param gasLimit Optional: the gas limit to use for the VRF callback transaction, defaults to 500000
     * @returns
     */
    openAndClaim(packId: BigNumberish, amount?: BigNumberish, gasLimit?: BigNumberish): Promise<TransactionResultWithId>;
    /**
     * Get the balance of LINK in the contract
     * @returns the balance of LINK in the contract
     */
    getLinkBalance(): Promise<CurrencyValue>;
    /**
     * Transfer LINK to this contract
     * @param amount the amount of LINK to transfer to the contract
     */
    transferLink(amount: Amount): Promise<void>;
    private getLinkContract;
}
//# sourceMappingURL=pack-vrf.d.ts.map