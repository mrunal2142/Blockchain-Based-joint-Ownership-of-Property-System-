'use strict';

var QueryParams = require('./QueryParams-5ef9418e.cjs.prod.js');
var thirdwebCheckout = require('./thirdweb-checkout-19f77563.cjs.prod.js');
var zod = require('zod');
var ERC165Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC165.json');
var Erc721Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC721.json');
var Erc1155Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC1155.json');
var ethers = require('ethers');
var invariant = require('tiny-invariant');
var ERC20Abi = require('@thirdweb-dev/contracts-js/dist/abis/IERC20.json');
require('bn.js');
require('@thirdweb-dev/contracts-js/dist/abis/IBurnableERC20.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDrop.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropERC20_V2.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase_V1.json');
require('@thirdweb-dev/contracts-js/dist/abis/IMintableERC20.json');
require('@thirdweb-dev/contracts-js/dist/abis/IMulticall.json');
require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC20.json');
require('@thirdweb-dev/contracts-js/dist/abis/IBurnableERC721.json');
require('@thirdweb-dev/contracts-js/dist/abis/IClaimableERC721.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDelayedReveal.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropERC721_V3.json');
require('@thirdweb-dev/contracts-js/dist/abis/IERC721Enumerable.json');
require('@thirdweb-dev/contracts-js/dist/abis/IERC721Supply.json');
require('@thirdweb-dev/contracts-js/dist/abis/ILazyMint.json');
require('@thirdweb-dev/contracts-js/dist/abis/IMintableERC721.json');
require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721.json');
require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC721_V1.json');
require('@thirdweb-dev/contracts-js/dist/abis/LazyMintWithTier.json');
require('@thirdweb-dev/contracts-js/dist/abis/IBurnableERC1155.json');
require('@thirdweb-dev/contracts-js/dist/abis/IClaimableERC1155.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDrop1155.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropERC1155_V2.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDropSinglePhase1155_V1.json');
require('@thirdweb-dev/contracts-js/dist/abis/IERC1155Enumerable.json');
require('@thirdweb-dev/contracts-js/dist/abis/IMintableERC1155.json');
require('@thirdweb-dev/contracts-js/dist/abis/ISignatureMintERC1155.json');
require('@thirdweb-dev/contracts-js/dist/abis/ERC2771Context.json');
require('@thirdweb-dev/contracts-js/dist/abis/IAppURI.json');
require('@thirdweb-dev/contracts-js/dist/abis/IContractMetadata.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDirectListings.json');
require('@thirdweb-dev/contracts-js/dist/abis/IEnglishAuctions.json');
require('@thirdweb-dev/contracts-js/dist/abis/IOffers.json');
require('@thirdweb-dev/contracts-js/dist/abis/IPackVRFDirect.json');
require('@thirdweb-dev/contracts-js/dist/abis/IPermissions.json');
require('@thirdweb-dev/contracts-js/dist/abis/IPermissionsEnumerable.json');
require('@thirdweb-dev/contracts-js/dist/abis/IPlatformFee.json');
require('@thirdweb-dev/contracts-js/dist/abis/IPrimarySale.json');
require('@thirdweb-dev/contracts-js/dist/abis/IRouter.json');
require('@thirdweb-dev/contracts-js/dist/abis/IRoyalty.json');
require('@thirdweb-dev/contracts-js/dist/abis/Ownable.json');
require('cross-fetch');
require('@thirdweb-dev/chains');
require('eventemitter3');
require('@thirdweb-dev/contracts-js/dist/abis/Forwarder.json');
require('@thirdweb-dev/storage');
require('@thirdweb-dev/contracts-js/dist/abis/Router.json');
require('@thirdweb-dev/contracts-js/dist/abis/IThirdwebContract.json');
require('@thirdweb-dev/contracts-js/dist/abis/IERC20Metadata.json');
require('merkletreejs');
require('fast-deep-equal');
require('uuid');
require('@thirdweb-dev/contracts-js/dist/abis/IERC721Metadata.json');
require('@thirdweb-dev/contracts-js/dist/abis/IERC1155Metadata.json');
require('@thirdweb-dev/contracts-js/dist/abis/IDelayedRevealDeprecated.json');
require('@thirdweb-dev/contracts-js/dist/abis/ContractPublisher.json');
require('@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryLogic.json');
require('@thirdweb-dev/contracts-js/dist/abis/TWMultichainRegistryRouter.json');
require('@thirdweb-dev/contracts-js/dist/abis/TWFactory.json');
require('@thirdweb-dev/contracts-js/dist/abis/TWRegistry.json');
require('bs58');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

var ERC165Abi__default = /*#__PURE__*/_interopDefault(ERC165Abi);
var Erc721Abi__default = /*#__PURE__*/_interopDefault(Erc721Abi);
var Erc1155Abi__default = /*#__PURE__*/_interopDefault(Erc1155Abi);
var invariant__default = /*#__PURE__*/_interopDefault(invariant);
var ERC20Abi__default = /*#__PURE__*/_interopDefault(ERC20Abi);

/**
 * @internal
 */
const DirectListingInputParamsSchema = zod.z.object({
  /**
   * The address of the asset being listed.
   */
  assetContractAddress: thirdwebCheckout.AddressSchema,
  /**
   * The ID of the token to list.
   */
  tokenId: thirdwebCheckout.BigNumberishSchema,
  /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: thirdwebCheckout.BigNumberishSchema.default(1),
  /**
   * The address of the currency to accept for the listing.
   */
  currencyContractAddress: thirdwebCheckout.AddressSchema.default(thirdwebCheckout.NATIVE_TOKEN_ADDRESS),
  /**
   * The price to pay per unit of NFTs listed.
   */
  pricePerToken: QueryParams.AmountSchema,
  /**
   * The start time of the listing.
   */
  startTimestamp: thirdwebCheckout.RawDateSchema.default(new Date()),
  /**
   * The end time of the listing.
   */
  endTimestamp: thirdwebCheckout.EndDateSchema,
  /**
   * Whether the listing is reserved to be bought from a specific set of buyers.
   */
  isReservedListing: zod.z.boolean().default(false)
});

/**
 * @public
 */

/**
 * Handles direct listings
 * @public
 */
class MarketplaceV3DirectListings {
  // utilities

  constructor(contractWrapper, storage) {
    QueryParams._defineProperty(this, "featureName", thirdwebCheckout.FEATURE_DIRECT_LISTINGS.name);
    QueryParams._defineProperty(this, "contractWrapper", void 0);
    QueryParams._defineProperty(this, "storage", void 0);
    QueryParams._defineProperty(this, "events", void 0);
    QueryParams._defineProperty(this, "interceptor", void 0);
    QueryParams._defineProperty(this, "encoder", void 0);
    QueryParams._defineProperty(this, "estimator", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new thirdwebCheckout.ContractEvents(this.contractWrapper);
    this.encoder = new thirdwebCheckout.ContractEncoder(this.contractWrapper);
    this.interceptor = new thirdwebCheckout.ContractInterceptor(this.contractWrapper);
    this.estimator = new thirdwebCheckout.GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }

  /** ******************************
   * READ FUNCTIONS
   *******************************/

  /**
   * Get the total number of direct listings.
   * @returns Returns the total number of direct listings created.
   * @public
   *
   * @example
   * ```javascript
   * const totalListings = await contract.directListings.getTotalCount();
   * ```
   */
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalListings();
  }

  /**
   * Get all direct listings.
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAll();
   * const priceOfFirstListing = listings[0].price;
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Direct listing object array
   */
  async getAll(filter) {
    const totalListings = await this.getTotalCount();
    let start = ethers.BigNumber.from(filter?.start || 0).toNumber();
    let end = totalListings.toNumber();
    if (end === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    let batches = await thirdwebCheckout.getAllInBatches(start, end, this.contractWrapper.readContract.getAllListings);
    rawListings = batches.flat();
    const filteredListings = this.applyFilter(rawListings, filter);
    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));
  }

  /**
   * Get all valid direct listings.
   *
   * A valid listing is where the listing is active,
   * and the creator still owns & has approved Marketplace to transfer the listed NFTs.
   *
   * @example
   * ```javascript
   * const listings = await contract.directListings.getAllValid();
   * const priceOfFirstListing = listings[0].price;
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Direct listing object array
   */
  async getAllValid(filter) {
    const totalListings = await this.getTotalCount();
    let start = ethers.BigNumber.from(filter?.start || 0).toNumber();
    let end = totalListings.toNumber();
    if (end === 0) {
      throw new Error(`No listings exist on the contract.`);
    }
    let rawListings = [];
    let batches = await thirdwebCheckout.getAllInBatches(start, end, this.contractWrapper.readContract.getAllValidListings);
    rawListings = batches.flat();
    const filteredListings = this.applyFilter(rawListings, filter);
    return await Promise.all(filteredListings.map(listing => this.mapListing(listing)));
  }

  /**
   * Get a direct listing by id.
   *
   * @param listingId - the listing id
   * @returns the Direct listing object
   *
   * @example
   * ```javascript
   * const listingId = 0;
   * const listing = await contract.directListings.getListing(listingId);
   * ```
   */
  async getListing(listingId) {
    const listing = await this.contractWrapper.readContract.getListing(listingId);
    return await this.mapListing(listing);
  }

  /**
   * Check whether a buyer is approved for a reserved listing.
   *
   * @param listingId - the listing id
   * @param buyer - buyer address
   */
  async isBuyerApprovedForListing(listingId, buyer) {
    const listing = await this.validateListing(ethers.BigNumber.from(listingId));
    if (!listing.isReservedListing) {
      throw new Error(`Listing ${listingId} is not a reserved listing.`);
    }
    return await this.contractWrapper.readContract.isBuyerApprovedForListing(listingId, buyer);
  }

  /**
   * Check whether a currency is approved for a listing.
   *
   * @param listingId - the listing id
   * @param currency - currency address
   */
  async isCurrencyApprovedForListing(listingId, currency) {
    await this.validateListing(ethers.BigNumber.from(listingId));
    return await this.contractWrapper.readContract.isCurrencyApprovedForListing(listingId, currency);
  }

  /**
   * Check price per token for an approved currency.
   *
   * @param listingId - the listing id
   * @param currencyContractAddress - currency contract address
   */
  async currencyPriceForListing(listingId, currencyContractAddress) {
    const listing = await this.validateListing(ethers.BigNumber.from(listingId));
    if (currencyContractAddress === listing.currencyContractAddress) {
      return listing.pricePerToken;
    }
    const isApprovedCurrency = await this.isCurrencyApprovedForListing(listingId, currencyContractAddress);
    if (!isApprovedCurrency) {
      throw new Error(`Currency ${currencyContractAddress} is not approved for Listing ${listingId}.`);
    }
    return await this.contractWrapper.readContract.currencyPriceForListing(listingId, currencyContractAddress);
  }

  /** ******************************
   * WRITE FUNCTIONS
   *******************************/

  /**
   * Create Direct Listing
   *
   * @remarks Create a new listing on the marketplace where people can buy an asset directly.
   *
   * @example
   * ```javascript
   * // Data of the listing you want to create
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to list
   *   tokenId: "0",
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()),
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.createListing(listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   * ```
   */
  async createListing(listing) {
    const parsedListing = DirectListingInputParamsSchema.parse(listing);
    await thirdwebCheckout.handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedPricePerToken = await thirdwebCheckout.normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    if (parsedListing.startTimestamp.lt(blockTime)) {
      parsedListing.startTimestamp = ethers.BigNumber.from(blockTime);
    }
    const receipt = await this.contractWrapper.sendTransaction("createListing", [{
      assetContract: parsedListing.assetContractAddress,
      tokenId: parsedListing.tokenId,
      quantity: parsedListing.quantity,
      currency: thirdwebCheckout.cleanCurrencyAddress(parsedListing.currencyContractAddress),
      pricePerToken: normalizedPricePerToken,
      startTimestamp: parsedListing.startTimestamp,
      endTimestamp: parsedListing.endTimestamp,
      reserved: parsedListing.isReservedListing
    }], {
      // Higher gas limit for create listing
      gasLimit: 500000
    });
    const event = this.contractWrapper.parseLogs("NewListing", receipt?.logs);
    return {
      id: event[0].args.listingId,
      receipt
    };
  }

  /**
   * Update a Direct listing with new metadata.
   *
   * Note: cannot update a listing with a new quantity of 0. Use `cancelDirectListing` to remove a listing instead.
   *
   * @param listing - the new listing information
   *
   * @example
   * ```javascript
   * // Data of the listing you want to update
   *
   * const listingId = 0; // ID of the listing you want to update
   *
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...", // should be same as original listing
   *   // token ID of the asset you want to list
   *   tokenId: "0", // should be same as original listing
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()), // can't change this if listing already active
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.updateListing(listingId, listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   * ```
   */
  async updateListing(listingId, listing) {
    const parsedListing = DirectListingInputParamsSchema.parse(listing);
    await thirdwebCheckout.handleTokenApproval(this.contractWrapper, this.getAddress(), parsedListing.assetContractAddress, parsedListing.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedPricePerToken = await thirdwebCheckout.normalizePriceValue(this.contractWrapper.getProvider(), parsedListing.pricePerToken, parsedListing.currencyContractAddress);
    const receipt = await this.contractWrapper.sendTransaction("updateListing", [listingId, {
      assetContract: parsedListing.assetContractAddress,
      tokenId: parsedListing.tokenId,
      quantity: parsedListing.quantity,
      currency: thirdwebCheckout.cleanCurrencyAddress(parsedListing.currencyContractAddress),
      pricePerToken: normalizedPricePerToken,
      startTimestamp: parsedListing.startTimestamp,
      endTimestamp: parsedListing.endTimestamp,
      reserved: parsedListing.isReservedListing
    }], {
      // Higher gas limit for create listing
      gasLimit: 500000
    });
    const event = this.contractWrapper.parseLogs("UpdatedListing", receipt?.logs);
    return {
      id: event[0].args.listingId,
      receipt
    };
  }

  /**
   * Cancel Direct Listing
   *
   * @remarks Cancel a direct listing on the marketplace
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to cancel
   * const listingId = 0;
   *
   * await contract.directListings.cancelListing(listingId);
   * ```
   */
  async cancelListing(listingId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("cancelListing", [listingId])
    };
  }

  /**
   * Buy from a Listing
   *
   * @remarks Buy from a specific direct listing from the marketplace.
   *
   * @example
   * ```javascript
   * // The ID of the listing you want to buy from
   * const listingId = 0;
   * // Quantity of the asset you want to buy
   * const quantityDesired = 1;
   *
   * await contract.directListings.buyFromListing(listingId, quantityDesired);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param quantityDesired - the quantity to buy
   * @param receiver - optional receiver of the bought listing if different from the connected wallet
   */
  async buyFromListing(listingId, quantityDesired, receiver) {
    const listing = await this.validateListing(ethers.BigNumber.from(listingId));
    const {
      valid,
      error
    } = await this.isStillValidListing(listing, quantityDesired);
    if (!valid) {
      throw new Error(`Listing ${listingId} is no longer valid. ${error}`);
    }
    const buyFor = receiver ? receiver : await this.contractWrapper.getSignerAddress();
    const quantity = ethers.BigNumber.from(quantityDesired);
    const value = ethers.BigNumber.from(listing.pricePerToken).mul(quantity);
    const overrides = (await this.contractWrapper.getCallOverrides()) || {};
    await thirdwebCheckout.setErc20Allowance(this.contractWrapper, value, listing.currencyContractAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("buyFromListing", [listingId, buyFor, quantity, listing.currencyContractAddress, value], overrides)
    };
  }

  /**
   * Approve buyer for reserved listing.
   *
   * @remarks Approve a buyer to buy from a reserved listing.
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want approve buyer for
   * const listingId = "0";
   *
   * await contract.directListings.approveBuyerForReservedListing(listingId, buyer);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param buyer - Address of buyer being approved
   */
  async approveBuyerForReservedListing(listingId, buyer) {
    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
    if (!isApproved) {
      return {
        receipt: await this.contractWrapper.sendTransaction("approveBuyerForListing", [listingId, buyer, true])
      };
    } else {
      throw new Error(`Buyer ${buyer} already approved for listing ${listingId}.`);
    }
  }

  /**
   * Revoke approval of a buyer for reserved listing.
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want approve buyer for
   * const listingId = "0";
   *
   * await contract.directListings.revokeBuyerApprovalForReservedListing(listingId, buyer);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param buyer - Address of buyer being approved
   */
  async revokeBuyerApprovalForReservedListing(listingId, buyer) {
    const isApproved = await this.isBuyerApprovedForListing(listingId, buyer);
    if (isApproved) {
      return {
        receipt: await this.contractWrapper.sendTransaction("approveBuyerForListing", [listingId, buyer, false])
      };
    } else {
      throw new Error(`Buyer ${buyer} not approved for listing ${listingId}.`);
    }
  }

  /**
   * Approve a currency for a listing.
   *
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want approve currency for
   * const listingId = "0";
   *
   * await contract.directListings.approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param currencyContractAddress - Address of currency being approved
   * @param pricePerTokenInCurrency - Price per token in the currency
   */
  async approveCurrencyForListing(listingId, currencyContractAddress, pricePerTokenInCurrency) {
    const listing = await this.validateListing(ethers.BigNumber.from(listingId));
    if (currencyContractAddress === listing.currencyContractAddress) {
      invariant__default["default"](pricePerTokenInCurrency === listing.pricePerToken, "Approving listing currency with a different price.");
    }
    const currencyPrice = await this.contractWrapper.readContract.currencyPriceForListing(listingId, currencyContractAddress);
    invariant__default["default"](pricePerTokenInCurrency === currencyPrice, "Currency already approved with this price.");
    return {
      receipt: await this.contractWrapper.sendTransaction("approveCurrencyForListing", [listingId, currencyContractAddress, pricePerTokenInCurrency])
    };
  }

  /**
   * Revoke approval of a currency from a listing.
   *
   *
   * @example
   * ```javascript
   * // The listing ID of the direct listing you want to revoke currency for
   * const listingId = "0";
   *
   * await contract.directListings.revokeCurrencyApprovalForListing(listingId, currencyContractAddress);
   * ```
   *
   * @param listingId - The listing id to buy
   * @param currencyContractAddress - Address of currency
   */
  async revokeCurrencyApprovalForListing(listingId, currencyContractAddress) {
    const listing = await this.validateListing(ethers.BigNumber.from(listingId));
    if (currencyContractAddress === listing.currencyContractAddress) {
      throw new Error(`Can't revoke approval for main listing currency.`);
    }
    const currencyPrice = await this.contractWrapper.readContract.currencyPriceForListing(listingId, currencyContractAddress);
    invariant__default["default"](!currencyPrice.isZero(), "Currency not approved.");
    return {
      receipt: await this.contractWrapper.sendTransaction("approveCurrencyForListing", [listingId, currencyContractAddress, ethers.BigNumber.from(0)])
    };
  }

  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/

  /**
   * Throws error if listing could not be found
   *
   * @param listingId - Listing to check for
   */
  async validateListing(listingId) {
    try {
      return await this.getListing(listingId);
    } catch (err) {
      console.error(`Error getting the listing with id ${listingId}`);
      throw err;
    }
  }

  /**
   * Helper method maps the auction listing to the direct listing interface.
   *
   * @internal
   * @param listing - The listing to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapListing(listing) {
    let status = thirdwebCheckout.Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (listing.status) {
      case 1:
        status = ethers.BigNumber.from(listing.startTimestamp).gt(blockTime) ? thirdwebCheckout.Status.Created : ethers.BigNumber.from(listing.endTimestamp).lt(blockTime) ? thirdwebCheckout.Status.Expired : thirdwebCheckout.Status.Active;
        break;
      case 2:
        status = thirdwebCheckout.Status.Completed;
        break;
      case 3:
        status = thirdwebCheckout.Status.Cancelled;
        break;
    }
    return {
      assetContractAddress: listing.assetContract,
      currencyContractAddress: listing.currency,
      pricePerToken: listing.pricePerToken.toString(),
      currencyValuePerToken: await thirdwebCheckout.fetchCurrencyValue(this.contractWrapper.getProvider(), listing.currency, listing.pricePerToken),
      id: listing.listingId.toString(),
      tokenId: listing.tokenId.toString(),
      quantity: listing.quantity.toString(),
      startTimeInSeconds: ethers.BigNumber.from(listing.startTimestamp).toNumber(),
      asset: await thirdwebCheckout.fetchTokenMetadataForContract(listing.assetContract, this.contractWrapper.getProvider(), listing.tokenId, this.storage),
      endTimeInSeconds: ethers.BigNumber.from(listing.endTimestamp).toNumber(),
      creatorAddress: listing.listingCreator,
      isReservedListing: listing.reserved,
      status: status
    };
  }

  /**
   * Use this method to check if a direct listing is still valid.
   *
   * Ways a direct listing can become invalid:
   * 1. The asset holder transferred the asset to another wallet
   * 2. The asset holder burned the asset
   * 3. The asset holder removed the approval on the marketplace
   *
   * @internal
   * @param listing - The listing to check.
   * @returns - True if the listing is valid, false otherwise.
   */
  async isStillValidListing(listing, quantity) {
    const approved = await thirdwebCheckout.isTokenApprovedForTransfer(this.contractWrapper.getProvider(), this.getAddress(), listing.assetContractAddress, listing.tokenId, listing.creatorAddress);
    if (!approved) {
      return {
        valid: false,
        error: `Token '${listing.tokenId}' from contract '${listing.assetContractAddress}' is not approved for transfer`
      };
    }
    const provider = this.contractWrapper.getProvider();
    const erc165 = new ethers.Contract(listing.assetContractAddress, ERC165Abi__default["default"], provider);
    const isERC721 = await erc165.supportsInterface(thirdwebCheckout.InterfaceId_IERC721);
    const isERC1155 = await erc165.supportsInterface(thirdwebCheckout.InterfaceId_IERC1155);
    if (isERC721) {
      const asset = new ethers.Contract(listing.assetContractAddress, Erc721Abi__default["default"], provider);
      const valid = (await asset.ownerOf(listing.tokenId)).toLowerCase() === listing.creatorAddress.toLowerCase();
      return {
        valid,
        error: valid ? undefined : `Seller is not the owner of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} anymore'`
      };
    } else if (isERC1155) {
      const asset = new ethers.Contract(listing.assetContractAddress, Erc1155Abi__default["default"], provider);
      const balance = await asset.balanceOf(listing.creatorAddress, listing.tokenId);
      const valid = balance.gte(quantity || listing.quantity);
      return {
        valid,
        error: valid ? undefined : `Seller does not have enough balance of Token '${listing.tokenId}' from contract '${listing.assetContractAddress} to fulfill the listing`
      };
    } else {
      return {
        valid: false,
        error: "Contract does not implement ERC 1155 or ERC 721."
      };
    }
  }
  applyFilter(listings, filter) {
    let rawListings = [...listings];
    if (filter) {
      if (filter.seller) {
        rawListings = rawListings.filter(seller => seller.listingCreator.toString().toLowerCase() === filter?.seller?.toString().toLowerCase());
      }
      if (filter.tokenContract) {
        rawListings = rawListings.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === filter?.tokenContract?.toString().toLowerCase());
      }
      if (filter.tokenId !== undefined) {
        rawListings = rawListings.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());
      }
    }
    return filter?.count && filter.count < rawListings.length ? rawListings.slice(0, filter.count) : rawListings;
  }
}

/**
 * @internal
 */
const EnglishAuctionInputParamsSchema = zod.z.object({
  /**
   * The address of the asset being auctioned.
   */
  assetContractAddress: thirdwebCheckout.AddressSchema,
  /**
   * The ID of the token to auction.
   */
  tokenId: thirdwebCheckout.BigNumberishSchema,
  /**
   * The quantity of tokens to include in the listing.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: thirdwebCheckout.BigNumberishSchema.default(1),
  /**
   * The address of the currency to accept for the listing.
   */
  currencyContractAddress: thirdwebCheckout.AddressSchema.default(thirdwebCheckout.NATIVE_TOKEN_ADDRESS),
  /**
   * The minimum price that a bid must be in order to be accepted.
   */
  minimumBidAmount: QueryParams.AmountSchema,
  /**
   * The buyout price of the auction.
   */
  buyoutBidAmount: QueryParams.AmountSchema,
  /**
   * This is a buffer e.g. x seconds.
   *
   * If a new winning bid is made less than x seconds before expirationTimestamp, the
   * expirationTimestamp is increased by x seconds.
   */
  timeBufferInSeconds: thirdwebCheckout.BigNumberishSchema.default(900),
  // 15 minutes by default

  /**
   * This is a buffer in basis points e.g. x%.
   *
   * To be considered as a new winning bid, a bid must be at least x% greater than
   * the current winning bid.
   */
  bidBufferBps: thirdwebCheckout.BigNumberishSchema.default(500),
  // 5% by default

  /**
   * The start time of the auction.
   */
  startTimestamp: thirdwebCheckout.RawDateSchema.default(new Date()),
  /**
   * The end time of the auction.
   */
  endTimestamp: thirdwebCheckout.EndDateSchema
});

/**
 * @public
 */

/**
 * Handles auctions
 * @public
 */
class MarketplaceV3EnglishAuctions {
  // utilities

  constructor(contractWrapper, storage) {
    QueryParams._defineProperty(this, "featureName", thirdwebCheckout.FEATURE_ENGLISH_AUCTIONS.name);
    QueryParams._defineProperty(this, "contractWrapper", void 0);
    QueryParams._defineProperty(this, "storage", void 0);
    QueryParams._defineProperty(this, "events", void 0);
    QueryParams._defineProperty(this, "interceptor", void 0);
    QueryParams._defineProperty(this, "encoder", void 0);
    QueryParams._defineProperty(this, "estimator", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new thirdwebCheckout.ContractEvents(this.contractWrapper);
    this.encoder = new thirdwebCheckout.ContractEncoder(this.contractWrapper);
    this.interceptor = new thirdwebCheckout.ContractInterceptor(this.contractWrapper);
    this.estimator = new thirdwebCheckout.GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }

  /** ******************************
   * READ FUNCTIONS
   *******************************/

  /**
   * Get the total number of english auctions.
   * @returns Returns the total number of auctions created.
   * @public
   *
   * @example
   * ```javascript
   * const totalAuctions = await contract.englishAuctions.getTotalCount();
   * ```
   */
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalAuctions();
  }

  /**
   * Get all auctions.
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Auction object array
   */
  async getAll(filter) {
    const totalAuctions = await this.getTotalCount();
    let start = ethers.BigNumber.from(filter?.start || 0).toNumber();
    let end = totalAuctions.toNumber();
    if (end === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    let batches = await thirdwebCheckout.getAllInBatches(start, end, this.contractWrapper.readContract.getAllAuctions);
    rawAuctions = batches.flat();
    const filteredAuctions = this.applyFilter(rawAuctions, filter);
    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));
  }

  /**
   * Get all valid auctions.
   *
   * @example
   * ```javascript
   * const auctions = await contract.englishAuctions.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Auction object array
   */
  async getAllValid(filter) {
    const totalAuctions = await this.getTotalCount();
    let start = ethers.BigNumber.from(filter?.start || 0).toNumber();
    let end = totalAuctions.toNumber();
    if (end === 0) {
      throw new Error(`No auctions exist on the contract.`);
    }
    let rawAuctions = [];
    let batches = await thirdwebCheckout.getAllInBatches(start, end, this.contractWrapper.readContract.getAllValidAuctions);
    rawAuctions = batches.flat();
    const filteredAuctions = this.applyFilter(rawAuctions, filter);
    return await Promise.all(filteredAuctions.map(auction => this.mapAuction(auction)));
  }

  /**
   * Get an Auction by id.
   *
   * @example
   * ```javascript
   * const auctionId = 0;
   * const auction = await contract.englishAuctions.getAuction(auctionId);
   * ```
   *
   * @param auctionId - the auction Id
   * @returns the Auction object
   */
  async getAuction(auctionId) {
    const auction = await this.contractWrapper.readContract.getAuction(auctionId);
    return await this.mapAuction(auction);
  }

  /**
   * Get Highest Bid
   *
   * @remarks Get the current highest bid of an active auction.
   *
   * @example
   * ```javascript
   * // The ID of the auction
   * const auctionId = 0;
   *
   * contract.englishAuctions.
   *   .getWinningBid(auctionId)
   *   .then((bid) => console.log(bid))
   *   .catch((err) => console.error(err));
   * ```
   */
  async getWinningBid(auctionId) {
    await this.validateAuction(ethers.BigNumber.from(auctionId));
    const bid = await this.contractWrapper.readContract.getWinningBid(auctionId);
    if (bid._bidder === ethers.constants.AddressZero) {
      return undefined;
    }
    return await this.mapBid(auctionId.toString(), bid._bidder, bid._currency, bid._bidAmount.toString());
  }

  /**
   * Check if a bid-amount is/will be a winning bid.
   *
   * @param auctionId - Auction Id
   * @param bidAmount - Amount to bid
   * @returns the Auction object
   */
  async isWinningBid(auctionId, bidAmount) {
    return await this.contractWrapper.readContract.isNewWinningBid(auctionId, bidAmount);
  }

  /**
   * Get Auction Winner
   *
   * @remarks Get the winner of the auction after an auction ends.
   *
   * @example
   * ```javascript
   * // The auction ID of the auction that closed
   * const auctionId = 0;
   *
   * contract.englishAuctions.
   *   .getWinner(auctionId)
   *   .then((auctionWinner) => console.log(auctionWinner))
   *   .catch((err) => console.error(err));
   * ```
   */
  async getWinner(auctionId) {
    const auction = await this.validateAuction(ethers.BigNumber.from(auctionId));
    const bid = await this.contractWrapper.readContract.getWinningBid(auctionId);
    const now = ethers.BigNumber.from(Math.floor(Date.now() / 1000));
    const endTime = ethers.BigNumber.from(auction.endTimeInSeconds);

    // if we have a winner in the map and the current time is past the endtime of the auction return the address of the winner
    if (now.gt(endTime) && bid._bidder !== ethers.constants.AddressZero) {
      return bid._bidder;
    }
    // otherwise fall back to query filter things

    // TODO this should be via indexer or direct contract call
    const closedAuctions = await this.contractWrapper.readContract.queryFilter(this.contractWrapper.readContract.filters.AuctionClosed());
    const closed = closedAuctions.find(a => a.args.auctionId.eq(ethers.BigNumber.from(auctionId)));
    if (!closed) {
      throw new Error(`Could not find auction with ID ${auctionId} in closed auctions`);
    }
    return closed.args.winningBidder;
  }

  /** ******************************
   * WRITE FUNCTIONS
   *******************************/

  /**
   * Create Auction
   *
   * @remarks Create a new auction where people can bid on an asset.
   *
   * @example
   * ```javascript
   * // Data of the auction you want to create
   * const auction = {
   *   // address of the contract of the asset you want to auction
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to auction
   *   tokenId: "0",
   *   // how many of the asset you want to auction
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the auctioned tokens
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // the minimum bid that will be accepted for the token
   *   minimumBidAmount: "1.5",
   *   // how much people would have to bid to instantly buy the asset
   *   buyoutBidAmount: "10",
   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
   *   timeBufferInSeconds: "900", // 15 minutes by default
   *   // A bid must be at least this much bps greater than the current winning bid
   *   bidBufferBps: "500", // 5% by default
   *   // when should the auction open up for bidding
   *   startTimestamp: new Date(Date.now()),
   *   // end time of auction
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   * }
   *
   * const tx = await contract.englishAuctions.createAuction(auction);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created auction
   * ```
   */
  async createAuction(auction) {
    const parsedAuction = EnglishAuctionInputParamsSchema.parse(auction);
    await thirdwebCheckout.handleTokenApproval(this.contractWrapper, this.getAddress(), parsedAuction.assetContractAddress, parsedAuction.tokenId, await this.contractWrapper.getSignerAddress());
    const normalizedBuyoutAmount = await thirdwebCheckout.normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.buyoutBidAmount, parsedAuction.currencyContractAddress);
    const normalizedMinBidAmount = await thirdwebCheckout.normalizePriceValue(this.contractWrapper.getProvider(), parsedAuction.minimumBidAmount, parsedAuction.currencyContractAddress);
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    if (parsedAuction.startTimestamp.lt(blockTime)) {
      parsedAuction.startTimestamp = ethers.BigNumber.from(blockTime);
    }
    const receipt = await this.contractWrapper.sendTransaction("createAuction", [{
      assetContract: parsedAuction.assetContractAddress,
      tokenId: parsedAuction.tokenId,
      quantity: parsedAuction.quantity,
      currency: thirdwebCheckout.cleanCurrencyAddress(parsedAuction.currencyContractAddress),
      minimumBidAmount: normalizedMinBidAmount,
      buyoutBidAmount: normalizedBuyoutAmount,
      timeBufferInSeconds: parsedAuction.timeBufferInSeconds,
      bidBufferBps: parsedAuction.bidBufferBps,
      startTimestamp: parsedAuction.startTimestamp,
      endTimestamp: parsedAuction.endTimestamp
    }], {
      // Higher gas limit for create auction
      gasLimit: 500000
    });
    const event = this.contractWrapper.parseLogs("NewAuction", receipt?.logs);
    return {
      id: event[0].args.auctionId,
      receipt
    };
  }

  /**
   * Buyout Auction
   *
   * @remarks Buy a specific auction from the marketplace.
   *
   * @example
   * ```javascript
   * // The auction ID of the asset you want to buy
   * const auctionId = 0;
   *
   * await contract.englishAuctions.buyoutAuction(auctionId);
   * ```
   */
  async buyoutAuction(auctionId) {
    const auction = await this.validateAuction(ethers.BigNumber.from(auctionId));
    const currencyMetadata = await thirdwebCheckout.fetchCurrencyMetadata(this.contractWrapper.getProvider(), auction.currencyContractAddress);
    return this.makeBid(auctionId, ethers.ethers.utils.formatUnits(auction.buyoutBidAmount, currencyMetadata.decimals));
  }

  /**
   * Bid On Auction
   *
   * @remarks Make a bid on an auction
   *
   * @example
   * ```javascript
   * // The auction ID of the asset you want to bid on
   * const auctionId = 0;
   * // The total amount you are willing to bid for auctioned tokens
   * const bidAmount = 1;
   *
   * await contract.englishAuctions.makeBid(auctionId, bidAmount);
   * ```
   */
  async makeBid(auctionId, bidAmount) {
    const auction = await this.validateAuction(ethers.BigNumber.from(auctionId));
    const normalizedBidAmount = await thirdwebCheckout.normalizePriceValue(this.contractWrapper.getProvider(), bidAmount, auction.currencyContractAddress);
    if (normalizedBidAmount.eq(ethers.BigNumber.from(0))) {
      throw new Error("Cannot make a bid with 0 value");
    }
    if (ethers.BigNumber.from(auction.buyoutBidAmount).gt(0) && normalizedBidAmount.gt(auction.buyoutBidAmount)) {
      throw new Error("Bid amount must be less than or equal to buyoutBidAmount");
    }
    const winningBid = await this.getWinningBid(auctionId);
    if (winningBid) {
      const isWinnner = await this.isWinningBid(auctionId, normalizedBidAmount);
      invariant__default["default"](isWinnner, "Bid price is too low based on the current winning bid and the bid buffer");
    } else {
      const tokenPrice = normalizedBidAmount;
      const minimumBidAmount = ethers.BigNumber.from(auction.minimumBidAmount);
      invariant__default["default"](tokenPrice.gte(minimumBidAmount), "Bid price is too low based on minimum bid amount");
    }
    const overrides = (await this.contractWrapper.getCallOverrides()) || {};
    await thirdwebCheckout.setErc20Allowance(this.contractWrapper, normalizedBidAmount, auction.currencyContractAddress, overrides);
    return {
      receipt: await this.contractWrapper.sendTransaction("bidInAuction", [auctionId, normalizedBidAmount], overrides)
    };
  }

  /**
   * Cancel Auction
   *
   * @remarks Cancel an auction on the marketplace
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to cancel
   * const auctionId = "0";
   *
   * await contract.englishAuctions.cancelAuction(auctionId);
   * ```
   */
  async cancelAuction(auctionId) {
    const winningBid = await this.getWinningBid(auctionId);
    if (winningBid) {
      throw new Error(`Bids already made.`);
    }
    return {
      receipt: await this.contractWrapper.sendTransaction("cancelAuction", [auctionId])
    };
  }

  /**
   * Close the Auction for the buyer
   *
   * @remarks Closes the Auction and executes the sale for the buyer.
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to close
   * const auction = "0";
   * await contract.englishAuctions.closeAuctionForBidder(auctionId);
   * ```
   *
   * @param auctionId - the auction id to close
   * @param closeFor - optionally pass the winning bid offeror address to close the auction on their behalf
   */
  async closeAuctionForBidder(auctionId, closeFor) {
    if (!closeFor) {
      closeFor = await this.contractWrapper.getSignerAddress();
    }
    const auction = await this.validateAuction(ethers.BigNumber.from(auctionId));
    try {
      return {
        receipt: await this.contractWrapper.sendTransaction("collectAuctionTokens", [ethers.BigNumber.from(auctionId)])
      };
    } catch (err) {
      if (err.message.includes("Marketplace: auction still active.")) {
        throw new thirdwebCheckout.AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
      } else {
        throw err;
      }
    }
  }

  /**
   * Close the Auction for the seller, i.e. the auction creator
   *
   * @remarks Closes the Auction and executes the sale for the seller.
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to close
   * const auctionId = "0";
   * await contract.englishAuctions.closeAuctionForSeller(auctionId);
   * ```
   *
   * @param auctionId - the auction id to close
   */
  async closeAuctionForSeller(auctionId) {
    const auction = await this.validateAuction(ethers.BigNumber.from(auctionId));
    try {
      return {
        receipt: await this.contractWrapper.sendTransaction("collectAuctionPayout", [ethers.BigNumber.from(auctionId)])
      };
    } catch (err) {
      if (err.message.includes("Marketplace: auction still active.")) {
        throw new thirdwebCheckout.AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
      } else {
        throw err;
      }
    }
  }

  /**
   * Execute the Auction Sale
   *
   * @remarks Closes the Auction and executes the sale for both parties.
   *
   * @example
   * ```javascript
   * // The ID of the auction you want to close
   * const auction = "0";
   * await contract.englishAuctions.executeSale(auctionId);
   * ```
   *
   * @param auctionId - the auction to close
   */
  async executeSale(auctionId) {
    const auction = await this.validateAuction(ethers.BigNumber.from(auctionId));
    try {
      const winningBid = await this.getWinningBid(auctionId);
      invariant__default["default"](winningBid, "No winning bid found");
      const closeForSeller = this.encoder.encode("collectAuctionPayout", [auctionId]);
      const closeForBuyer = this.encoder.encode("collectAuctionTokens", [auctionId]);
      return await this.contractWrapper.multiCall([closeForSeller, closeForBuyer]);
    } catch (err) {
      if (err.message.includes("Marketplace: auction still active.")) {
        throw new thirdwebCheckout.AuctionHasNotEndedError(auctionId.toString(), auction.endTimeInSeconds.toString());
      } else {
        throw err;
      }
    }
  }

  /**
   * Get the buffer in basis points between bids for an auction.
   *
   * @param auctionId - id of the auction
   */
  async getBidBufferBps(auctionId) {
    return (await this.getAuction(auctionId)).bidBufferBps;
  }

  /**
   * returns the minimum bid a user can place to outbid the previous highest bid
   * @param auctionId - id of the auction
   */
  async getMinimumNextBid(auctionId) {
    // we can fetch all of these at the same time using promise.all
    const [currentBidBufferBps, winningBid, auction] = await Promise.all([this.getBidBufferBps(auctionId), this.getWinningBid(auctionId), await this.validateAuction(ethers.BigNumber.from(auctionId))]);
    const currentBidOrReservePrice = winningBid ?
    // if there is a winning bid use the value of it
    ethers.BigNumber.from(winningBid.bidAmount) :
    // if there is no winning bid use the reserve price
    ethers.BigNumber.from(auction.minimumBidAmount);
    const minimumNextBid = currentBidOrReservePrice.add(
    // the addition of the current bid and the buffer
    // (have to divide by 10000 to get the fraction of the buffer (since it's in basis points))
    currentBidOrReservePrice.mul(currentBidBufferBps).div(10000));

    // it's more useful to return a currency value here
    return thirdwebCheckout.fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currencyContractAddress, minimumNextBid);
  }

  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/

  /**
   * Throws error if auction could not be found
   *
   * @param auctionId - Auction to check for
   */
  async validateAuction(auctionId) {
    try {
      return await this.getAuction(auctionId);
    } catch (err) {
      console.error(`Error getting the auction with id ${auctionId}`);
      throw err;
    }
  }

  /**
   * Helper method maps the auction to the auction interface.
   *
   * @internal
   * @param auction - The auction to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapAuction(auction) {
    let status = thirdwebCheckout.Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (auction.status) {
      case 1:
        status = ethers.BigNumber.from(auction.startTimestamp).gt(blockTime) ? thirdwebCheckout.Status.Created : ethers.BigNumber.from(auction.endTimestamp).lt(blockTime) ? thirdwebCheckout.Status.Expired : thirdwebCheckout.Status.Active;
        break;
      case 2:
        status = thirdwebCheckout.Status.Completed;
        break;
      case 3:
        status = thirdwebCheckout.Status.Cancelled;
        break;
    }
    return {
      id: auction.auctionId.toString(),
      creatorAddress: auction.auctionCreator,
      assetContractAddress: auction.assetContract,
      tokenId: auction.tokenId.toString(),
      quantity: auction.quantity.toString(),
      currencyContractAddress: auction.currency,
      minimumBidAmount: auction.minimumBidAmount.toString(),
      minimumBidCurrencyValue: await thirdwebCheckout.fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.minimumBidAmount),
      buyoutBidAmount: auction.buyoutBidAmount.toString(),
      buyoutCurrencyValue: await thirdwebCheckout.fetchCurrencyValue(this.contractWrapper.getProvider(), auction.currency, auction.buyoutBidAmount),
      timeBufferInSeconds: ethers.BigNumber.from(auction.timeBufferInSeconds).toNumber(),
      bidBufferBps: ethers.BigNumber.from(auction.bidBufferBps).toNumber(),
      startTimeInSeconds: ethers.BigNumber.from(auction.startTimestamp).toNumber(),
      endTimeInSeconds: ethers.BigNumber.from(auction.endTimestamp).toNumber(),
      asset: await thirdwebCheckout.fetchTokenMetadataForContract(auction.assetContract, this.contractWrapper.getProvider(), auction.tokenId, this.storage),
      status: status
    };
  }

  /**
   * Maps an auction-bid to the strict interface
   *
   * @internal
   * @param bid
   * @returns - A `Bid` object
   */
  async mapBid(auctionId, bidderAddress, currencyContractAddress, bidAmount) {
    return {
      auctionId,
      bidderAddress,
      currencyContractAddress,
      bidAmount,
      bidAmountCurrencyValue: await thirdwebCheckout.fetchCurrencyValue(this.contractWrapper.getProvider(), currencyContractAddress, bidAmount)
    };
  }
  applyFilter(auctions, filter) {
    let rawAuctions = [...auctions];
    if (filter) {
      if (filter.seller) {
        rawAuctions = rawAuctions.filter(seller => seller.auctionCreator.toString().toLowerCase() === filter?.seller?.toString().toLowerCase());
      }
      if (filter.tokenContract) {
        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === filter?.tokenContract?.toString().toLowerCase());
      }
      if (filter.tokenId !== undefined) {
        rawAuctions = rawAuctions.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());
      }
    }
    return filter?.count && filter.count < rawAuctions.length ? rawAuctions.slice(0, filter.count) : rawAuctions;
  }
}

/**
 * @internal
 */
const OfferInputParamsSchema = zod.z.object({
  /**
   * The address of the asset being sought.
   */
  assetContractAddress: thirdwebCheckout.AddressSchema,
  /**
   * The ID of the token.
   */
  tokenId: thirdwebCheckout.BigNumberishSchema,
  /**
   * The quantity of tokens to buy.
   *
   * For ERC721s, this value should always be 1 (and will be forced internally regardless of what is passed here).
   */
  quantity: thirdwebCheckout.BigNumberishSchema.default(1),
  /**
   * The address of the currency offered for the NFTs.
   */
  currencyContractAddress: thirdwebCheckout.AddressSchema.default(thirdwebCheckout.NATIVE_TOKEN_ADDRESS),
  /**
   * The total offer amount for the NFTs.
   */
  totalPrice: QueryParams.AmountSchema,
  /**
   * The end time of the offer.
   */
  endTimestamp: thirdwebCheckout.EndDateSchema
});

/**
 * @public
 */

/**
 * Handles marketplace offers
 * @public
 */
class MarketplaceV3Offers {
  // utilities

  constructor(contractWrapper, storage) {
    QueryParams._defineProperty(this, "featureName", thirdwebCheckout.FEATURE_OFFERS.name);
    QueryParams._defineProperty(this, "contractWrapper", void 0);
    QueryParams._defineProperty(this, "storage", void 0);
    QueryParams._defineProperty(this, "events", void 0);
    QueryParams._defineProperty(this, "interceptor", void 0);
    QueryParams._defineProperty(this, "encoder", void 0);
    QueryParams._defineProperty(this, "estimator", void 0);
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.events = new thirdwebCheckout.ContractEvents(this.contractWrapper);
    this.encoder = new thirdwebCheckout.ContractEncoder(this.contractWrapper);
    this.interceptor = new thirdwebCheckout.ContractInterceptor(this.contractWrapper);
    this.estimator = new thirdwebCheckout.GasCostEstimator(this.contractWrapper);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }

  /** ******************************
   * READ FUNCTIONS
   *******************************/

  /**
   * Get the total number of offers
   * @returns Returns the total number of offers created.
   * @public
   *
   * @example
   * ```javascript
   * const totalOffers = await contract.offers.getTotalCount();
   * ```
   */
  async getTotalCount() {
    return await this.contractWrapper.readContract.totalOffers();
  }

  /**
   * Get all offers.
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAll();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Offer object array
   */
  async getAll(filter) {
    const totalOffers = await this.getTotalCount();
    let start = ethers.BigNumber.from(filter?.start || 0).toNumber();
    let end = totalOffers.toNumber();
    if (end === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    let batches = await thirdwebCheckout.getAllInBatches(start, end, this.contractWrapper.readContract.getAllOffers);
    rawOffers = batches.flat();
    const filteredOffers = this.applyFilter(rawOffers, filter);
    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));
  }

  /**
   * Get all valid offers.
   *
   * @example
   * ```javascript
   * const offers = await contract.offers.getAllValid();
   * ```
   *
   * @param filter - optional filter parameters
   * @returns the Offer object array
   */
  async getAllValid(filter) {
    const totalOffers = await this.getTotalCount();
    let start = ethers.BigNumber.from(filter?.start || 0).toNumber();
    let end = totalOffers.toNumber();
    if (end === 0) {
      throw new Error(`No offers exist on the contract.`);
    }
    let rawOffers = [];
    let batches = await thirdwebCheckout.getAllInBatches(start, end, this.contractWrapper.readContract.getAllValidOffers);
    rawOffers = batches.flat();
    const filteredOffers = this.applyFilter(rawOffers, filter);
    return await Promise.all(filteredOffers.map(offer => this.mapOffer(offer)));
  }

  /**
   * Get a offer by id
   *
   * @example
   * ```javascript
   * const offerId = 0;
   * const offer = await contract.offers.getOffer(offerId);
   * ```
   *
   * @param offerId - the listing id
   * @returns the Direct listing object
   */
  async getOffer(offerId) {
    const offer = await this.contractWrapper.readContract.getOffer(offerId);
    return await this.mapOffer(offer);
  }

  /** ******************************
   * WRITE FUNCTIONS
   *******************************/

  /**
   * Make Offer
   *
   * @remarks Make an offer on the marketplace for an asset.
   *
   * @example
   * ```javascript
   * // Data of the offer you want to make
   * const offer = {
   *   // address of the contract the asset you want to make an offer for
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to buy
   *   tokenId: "0",
   *   // how many of the asset you want to buy
   *   quantity: 1,
   *   // address of the currency contract that you offer to pay in
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // Total price you offer to pay for the mentioned token(s)
   *   totalPrice: "1.5",
   *   // Offer valid until
   *   endTimestamp: new Date(),
   * }
   *
   * const tx = await contract.offers.makeOffer(offer);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created offer
   * ```
   */
  async makeOffer(offer) {
    const parsedOffer = OfferInputParamsSchema.parse(offer);
    const chainId = await this.contractWrapper.getChainID();
    const currency = thirdwebCheckout.isNativeToken(parsedOffer.currencyContractAddress) ? thirdwebCheckout.NATIVE_TOKENS[chainId].wrapped.address : parsedOffer.currencyContractAddress;
    const normalizedTotalPrice = await thirdwebCheckout.normalizePriceValue(this.contractWrapper.getProvider(), parsedOffer.totalPrice, currency);
    const overrides = await this.contractWrapper.getCallOverrides();
    await thirdwebCheckout.setErc20Allowance(this.contractWrapper, normalizedTotalPrice, currency, overrides);
    const receipt = await this.contractWrapper.sendTransaction("makeOffer", [{
      assetContract: parsedOffer.assetContractAddress,
      tokenId: parsedOffer.tokenId,
      quantity: parsedOffer.quantity,
      currency: currency,
      totalPrice: normalizedTotalPrice,
      expirationTimestamp: parsedOffer.endTimestamp
    }], {
      // Higher gas limit for create listing
      gasLimit: 500000
    });
    const event = this.contractWrapper.parseLogs("NewOffer", receipt?.logs);
    return {
      id: event[0].args.offerId,
      receipt
    };
  }

  /**
   * Cancel Offer
   *
   * @remarks Cancel an offer on the marketplace
   *
   * @example
   * ```javascript
   * // The ID of the offer you want to cancel
   * const offerId = "0";
   *
   * await contract.offers.cancelOffer(offerId);
   * ```
   */
  async cancelOffer(offerId) {
    return {
      receipt: await this.contractWrapper.sendTransaction("cancelOffer", [offerId])
    };
  }

  /**
   * Accept an offer
   *
   * @example
   * ```javascript
   * // The ID of the offer you want to accept
   * const offerId = 0;
   *
   * await contract.offers.acceptOffer(offerId);
   * ```
   *
   * @param offerId - The offer id
   */
  async acceptOffer(offerId) {
    const offer = await this.validateOffer(ethers.BigNumber.from(offerId));
    const {
      valid,
      error
    } = await this.isStillValidOffer(offer);
    if (!valid) {
      throw new Error(`Offer ${offerId} is no longer valid. ${error}`);
    }
    const overrides = (await this.contractWrapper.getCallOverrides()) || {};
    await thirdwebCheckout.handleTokenApproval(this.contractWrapper, this.getAddress(), offer.assetContractAddress, offer.tokenId, await this.contractWrapper.getSignerAddress());
    return {
      receipt: await this.contractWrapper.sendTransaction("acceptOffer", [offerId], overrides)
    };
  }

  /** ******************************
   * PRIVATE FUNCTIONS
   *******************************/

  /**
   * Throws error if offer could not be found
   *
   * @param offerId - offer to check for
   */
  async validateOffer(offerId) {
    try {
      return await this.getOffer(offerId);
    } catch (err) {
      console.error(`Error getting the offer with id ${offerId}`);
      throw err;
    }
  }

  /**
   * Helper method maps the offer to the offer interface.
   *
   * @internal
   * @param offer - The offer to map, as returned from the contract.
   * @returns - The mapped interface.
   */
  async mapOffer(offer) {
    let status = thirdwebCheckout.Status.UNSET;
    const block = await this.contractWrapper.getProvider().getBlock("latest");
    const blockTime = block.timestamp;
    switch (offer.status) {
      case 1:
        status = ethers.BigNumber.from(offer.expirationTimestamp).lt(blockTime) ? thirdwebCheckout.Status.Expired : thirdwebCheckout.Status.Active;
        break;
      case 2:
        status = thirdwebCheckout.Status.Completed;
        break;
      case 3:
        status = thirdwebCheckout.Status.Cancelled;
        break;
    }
    return {
      id: offer.offerId.toString(),
      offerorAddress: offer.offeror,
      assetContractAddress: offer.assetContract,
      currencyContractAddress: offer.currency,
      tokenId: offer.tokenId.toString(),
      quantity: offer.quantity.toString(),
      totalPrice: offer.totalPrice.toString(),
      currencyValue: await thirdwebCheckout.fetchCurrencyValue(this.contractWrapper.getProvider(), offer.currency, offer.totalPrice),
      asset: await thirdwebCheckout.fetchTokenMetadataForContract(offer.assetContract, this.contractWrapper.getProvider(), offer.tokenId, this.storage),
      endTimeInSeconds: ethers.BigNumber.from(offer.expirationTimestamp).toNumber(),
      status: status
    };
  }

  /**
   * Use this method to check if an offer is still valid.
   *
   * Ways an offer can become invalid:
   * 1. The offer has expired
   * 2. The offeror doesn't have enough balance of currency tokens
   * 3. The offeror removed the approval of currency tokens on the marketplace
   *
   * @internal
   * @param offer - The offer to check.
   * @returns - True if the offer is valid, false otherwise.
   */
  async isStillValidOffer(offer) {
    const now = ethers.BigNumber.from(Math.floor(Date.now() / 1000));
    if (now.gt(offer.endTimeInSeconds)) {
      return {
        valid: false,
        error: `Offer with ID ${offer.id} has expired`
      };
    }
    const chainId = await this.contractWrapper.getChainID();
    const currency = thirdwebCheckout.isNativeToken(offer.currencyContractAddress) ? thirdwebCheckout.NATIVE_TOKENS[chainId].wrapped.address : offer.currencyContractAddress;
    const provider = this.contractWrapper.getProvider();
    const erc20 = new thirdwebCheckout.ContractWrapper(provider, currency, ERC20Abi__default["default"], {});
    const offerorBalance = await erc20.readContract.balanceOf(offer.offerorAddress);
    if (offerorBalance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} doesn't have enough balance of token ${currency}`
      };
    }
    const offerorAllowance = await erc20.readContract.allowance(offer.offerorAddress, this.getAddress());
    if (offerorAllowance.lt(offer.totalPrice)) {
      return {
        valid: false,
        error: `Offeror ${offer.offerorAddress} hasn't approved enough amount of token ${currency}`
      };
    }
    return {
      valid: true,
      error: ""
    };
  }
  applyFilter(offers, filter) {
    let rawOffers = [...offers];
    if (filter) {
      if (filter.offeror) {
        rawOffers = rawOffers.filter(offeror => offeror.offeror.toString().toLowerCase() === filter?.offeror?.toString().toLowerCase());
      }
      if (filter.tokenContract) {
        rawOffers = rawOffers.filter(tokenContract => tokenContract.assetContract.toString().toLowerCase() === filter?.tokenContract?.toString().toLowerCase());
      }
      if (filter.tokenId !== undefined) {
        rawOffers = rawOffers.filter(tokenContract => tokenContract.tokenId.toString() === filter?.tokenId?.toString());
      }
    }
    return filter?.count && filter.count < rawOffers.length ? rawOffers.slice(0, filter.count) : rawOffers;
  }
}

/**
 * Create your own whitelabel marketplace that enables users to buy and sell any digital assets.
 *
 * @example
 *
 * ```javascript
 * import { ThirdwebSDK } from "@thirdweb-dev/sdk";
 *
 * const sdk = new ThirdwebSDK("{{chainName}}");
 * const contract = await sdk.getContract("{{contract_address}}", "marketplace");
 * ```
 *
 * @public
 */
class MarketplaceV3 {
  /**
   * @internal
   */

  /**
   * Direct listings
   * @remarks Create and manage direct listings in your marketplace.
   * ```javascript
   * // Data of the listing you want to create
   * const listing = {
   *   // address of the contract the asset you want to list is on
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to list
   *   tokenId: "0",
   *   // how many of the asset you want to list
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the listing
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // The price to pay per unit of NFTs listed.
   *   pricePerToken: 1.5,
   *   // when should the listing open up for offers
   *   startTimestamp: new Date(Date.now()),
   *   // how long the listing will be open for
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   *   // Whether the listing is reserved for a specific set of buyers.
   *   isReservedListing: false
   * }
   *
   * const tx = await contract.directListings.createListing(listing);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created listing
   *
   * // And on the buyers side:
   * // The ID of the listing you want to buy from
   * const listingId = 0;
   * // Quantity of the asset you want to buy
   * const quantityDesired = 1;
   *
   * await contract.directListings.buyFromListing(listingId, quantityDesired);
   * ```
   */
  get directListings() {
    return thirdwebCheckout.assertEnabled(this.detectDirectListings(), thirdwebCheckout.FEATURE_DIRECT_LISTINGS);
  }
  /**
   * Auctions
   * @remarks Create and manage auctions in your marketplace.
   * @example
   * ```javascript
   * // Data of the auction you want to create
   * const auction = {
   *   // address of the contract of the asset you want to auction
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to auction
   *   tokenId: "0",
   *   // how many of the asset you want to auction
   *   quantity: 1,
   *   // address of the currency contract that will be used to pay for the auctioned tokens
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // the minimum bid that will be accepted for the token
   *   minimumBidAmount: "1.5",
   *   // how much people would have to bid to instantly buy the asset
   *   buyoutBidAmount: "10",
   *   // If a bid is made less than these many seconds before expiration, the expiration time is increased by this.
   *   timeBufferInSeconds: "1000",
   *   // A bid must be at least this much bps greater than the current winning bid
   *   bidBufferBps: "100", // 100 bps stands for 1%
   *   // when should the auction open up for bidding
   *   startTimestamp: new Date(Date.now()),
   *   // end time of auction
   *   endTimestamp: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
   * }
   *
   * const tx = await contract.englishAuctions.createAuction(auction);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created auction
   *
   * // And on the buyers side:
   * // The auction ID of the asset you want to bid on
   * const auctionId = 0;
   * // The total amount you are willing to bid for auctioned tokens
   * const bidAmount = 1;
   *
   * await contract.englishAuctions.makeBid(auctionId, bidAmount);
   * ```
   */
  get englishAuctions() {
    return thirdwebCheckout.assertEnabled(this.detectEnglishAuctions(), thirdwebCheckout.FEATURE_ENGLISH_AUCTIONS);
  }

  /**
   * Offers
   * @remarks Make and manage offers.
   * @example
   * ```javascript
   * // Data of the offer you want to make
   * const offer = {
   *   // address of the contract the asset you want to make an offer for
   *   assetContractAddress: "0x...",
   *   // token ID of the asset you want to buy
   *   tokenId: "0",
   *   // how many of the asset you want to buy
   *   quantity: 1,
   *   // address of the currency contract that you offer to pay in
   *   currencyContractAddress: NATIVE_TOKEN_ADDRESS,
   *   // Total price you offer to pay for the mentioned token(s)
   *   totalPrice: "1.5",
   *   // Offer valid until
   *   endTimestamp: new Date(),
   * }
   *
   * const tx = await contract.offers.makeOffer(offer);
   * const receipt = tx.receipt; // the transaction receipt
   * const id = tx.id; // the id of the newly created offer
   *
   * // And on the seller's side:
   * // The ID of the offer you want to accept
   * const offerId = 0;
   * await contract.offers.acceptOffer(offerId);
   * ```
   */
  get offers() {
    return thirdwebCheckout.assertEnabled(this.detectOffers(), thirdwebCheckout.FEATURE_OFFERS);
  }
  get chainId() {
    return this._chainId;
  }
  constructor(network, address, storage) {
    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    let abi = arguments.length > 4 ? arguments[4] : undefined;
    let chainId = arguments.length > 5 ? arguments[5] : undefined;
    let contractWrapper = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : new thirdwebCheckout.ContractWrapper(network, address, abi, options);
    QueryParams._defineProperty(this, "abi", void 0);
    QueryParams._defineProperty(this, "contractWrapper", void 0);
    QueryParams._defineProperty(this, "storage", void 0);
    QueryParams._defineProperty(this, "encoder", void 0);
    QueryParams._defineProperty(this, "events", void 0);
    QueryParams._defineProperty(this, "estimator", void 0);
    QueryParams._defineProperty(this, "platformFees", void 0);
    QueryParams._defineProperty(this, "metadata", void 0);
    QueryParams._defineProperty(this, "roles", void 0);
    QueryParams._defineProperty(this, "interceptor", void 0);
    QueryParams._defineProperty(this, "_chainId", void 0);
    this._chainId = chainId;
    this.abi = abi;
    this.contractWrapper = contractWrapper;
    this.storage = storage;
    this.metadata = new thirdwebCheckout.ContractMetadata(this.contractWrapper, thirdwebCheckout.MarketplaceContractSchema, this.storage);
    this.roles = new thirdwebCheckout.ContractRoles(this.contractWrapper, MarketplaceV3.contractRoles);
    this.encoder = new thirdwebCheckout.ContractEncoder(this.contractWrapper);
    this.estimator = new thirdwebCheckout.GasCostEstimator(this.contractWrapper);
    this.events = new thirdwebCheckout.ContractEvents(this.contractWrapper);
    this.platformFees = new thirdwebCheckout.ContractPlatformFee(this.contractWrapper);
    this.interceptor = new thirdwebCheckout.ContractInterceptor(this.contractWrapper);
  }
  onNetworkUpdated(network) {
    this.contractWrapper.updateSignerOrProvider(network);
  }
  getAddress() {
    return this.contractWrapper.readContract.address;
  }

  /**
   * @internal
   */
  async call(functionName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return this.contractWrapper.call(functionName, ...args);
  }

  /** ********************
   * FEATURE DETECTION
   * ********************/

  detectDirectListings() {
    if (thirdwebCheckout.detectContractFeature(this.contractWrapper, "DirectListings")) {
      return new MarketplaceV3DirectListings(this.contractWrapper, this.storage);
    }
    return undefined;
  }
  detectEnglishAuctions() {
    if (thirdwebCheckout.detectContractFeature(this.contractWrapper, "EnglishAuctions")) {
      return new MarketplaceV3EnglishAuctions(this.contractWrapper, this.storage);
    }
    return undefined;
  }
  detectOffers() {
    if (thirdwebCheckout.detectContractFeature(this.contractWrapper, "Offers")) {
      return new MarketplaceV3Offers(this.contractWrapper, this.storage);
    }
    return undefined;
  }
}
QueryParams._defineProperty(MarketplaceV3, "contractRoles", ["admin", "lister", "asset"]);

exports.MarketplaceV3 = MarketplaceV3;
